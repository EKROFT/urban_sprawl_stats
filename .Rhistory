install.packages("vegan")
library(vegan)
setwd("~/")
data(BCI)
H<-diversity(BCI)
head(H)
D1<-diversity(BCI, index="Simpson")
D1<-diversity(BCI, index="simpson")
head(D1)
D2<-diversity(BCI,index="invsimpson", base=2)
head(D2)
#species richness
head(specnumber(BCI))
head(rowSums(BCI>0))
#Pielou's evenness
J<-H/log(specnumber(BCI))
head(J)
#Renyi's entropy and Hill's number
R<-renyi(BCI, scales=2)
head(R)
head(N2) # inverse simpson
head(N2) # inverse simpson
N2<- renyi(BCI, scales = 2, hill = TRUE)
head(N2)
k<-sample(nrow(BCI,6))
k<-sample(nrow(BCI),6)
R <- renyi(BCI[k,])
plot(R)
rs <- rowSums(BCI)
quantile(rs)
Srar <- rarefy(BCI, min(rs))
head(Srar)
rarecurve(BCI, sample = min(rs))
##Part 2 - Dissimilarity
data("varespec")
euc_dij <- vegdist(varespec, method = "euclidean")
bc_dij <- vegdist(varespec)
hell_dij <- vegdist(decostand(varespec, method = "hellinger"),
method = "euclidean")
#PCA
data(varespec)
data(varechem)
#PCA
library(vegan)
class(varespec)
dim(varespec)
head(varespec[,1:6], n = 5)
head(varechem)
pca <- rda(decostand(varespec, method = "hellinger"), scale = TRUE)
pca
rda(decostand(varespec, method = "hellinger"), scale = FALSE)
#plot
biplot(pca, scaling = "symmetric")
#eigenvalues quantify the inertia(variance) explained by each axis
screeplot(pca, bstick = TRUE, type = "l",
main = NULL)
summary(eigenvals(pca))
setwd("~/")
#Part 1 - Diversity Metrics
data(BCI)
#the default index is Shannon's
H<-diversity(BCI)
head(H)
#for other ones, specify index
D1<-diversity(BCI, index="simpson")
head(D1)
D2<-diversity(BCI,index="invsimpson", base=2)
head(D2)
#species richness
head(specnumber(BCI))
head(rowSums(BCI>0))
#Pielou's evenness
J<-H/log(specnumber(BCI))
head(J)
#Renyi's entropy and Hill's number
R<-renyi(BCI, scales=2)
head(R)
N2<- renyi(BCI, scales = 2, hill = TRUE)
head(N2)
k<-sample(nrow(BCI),6)
R <- renyi(BCI[k,])
plot(R)
#Rarefaction
rs <- rowSums(BCI)
quantile(rs)
Srar <- rarefy(BCI, min(rs))
head(Srar)
rarecurve(BCI, sample = min(rs))
##Part 2 - Dissimilarity
data("varespec")
#vegdist computes dissimiliraity measures
#decostand computes standardizations (standardizing data)
euc_dij <- vegdist(varespec, method = "euclidean")
bc_dij <- vegdist(varespec)
hell_dij <- vegdist(decostand(varespec, method = "hellinger"),
method = "euclidean")
##Part 3 - Ordination (unconstrained)
#PCA
library(vegan)
data(varespec)
data(varechem)
class(varespec)
dim(varespec)#number of samples, species
head(varespec[,1:6], n = 5)
head(varechem)
#pca is fitted using rda
pca <- rda(decostand(varespec, method = "hellinger"), scale = TRUE)
pca
#if we do scale=False
rda(decostand(varespec, method = "hellinger"), scale = FALSE)
#plot
biplot(pca, scaling = "symmetric")
head(eigenvals(pca), 5)
#eigenvalues quantify the inertia(variance) explained by each axis
screeplot(pca, bstick = TRUE, type = "l",
main = NULL)
#a screeplot of the eigenvalues, looking for a drastic change in slope, where this happens
#it shows you where to start(in this case stop after PC2)
#where your eigenvalues remain above the broken stick, this should be included
summary(eigenvals(pca))
#Correspondance Analysis
#this is a weighted form of PCA
#te row and column sums are used as weights and this has the effect of
#urning the analysis into one of relative composition
#he weighting is a trick to get linear-based software to fit non-linear responses
#hese nonlinear response are assumed to unimodal Gaussian curves, all wit
#qual height and tolerance widths, and equally spaced optima
##Part 1 - Diversity Metrics
data(BCI)
#the default index is Shannon's
H<-diversity(BCI)
head(H)
#for other ones, specify index
D1<-diversity(BCI, index="simpson")
head(D1)
D2<-diversity(BCI,index="invsimpson", base=2)
head(D2)
#species richness
head(specnumber(BCI))
head(rowSums(BCI>0))
#Pielou's evenness
J<-H/log(specnumber(BCI))
head(J)
#Renyi's entropy and Hill's number
R<-renyi(BCI, scales=2)
head(R)
N2<- renyi(BCI, scales = 2, hill = TRUE)
head(N2)
k<-sample(nrow(BCI),6)
R <- renyi(BCI[k,])
plot(R)
#Rarefaction
rs <- rowSums(BCI)
quantile(rs)
Srar <- rarefy(BCI, min(rs))
head(Srar)
rarecurve(BCI, sample = min(rs))
##Part 2 - Dissimilarity
data("varespec")
#vegdist computes dissimiliraity measures
#decostand computes standardizations (standardizing data)
euc_dij <- vegdist(varespec, method = "euclidean")
bc_dij <- vegdist(varespec)
hell_dij <- vegdist(decostand(varespec, method = "hellinger"),
method = "euclidean")
##Part 3 - Ordination (unconstrained)
#PCA
library(vegan)
data(varespec)
data(varechem)
class(varespec)
dim(varespec)#number of samples, species
head(varespec[,1:6], n = 5)
head(varechem)
#pca is fitted using rda
pca <- rda(decostand(varespec, method = "hellinger"), scale = TRUE)
pca
#if we do scale=False
rda(decostand(varespec, method = "hellinger"), scale = FALSE)
#plot
biplot(pca, scaling = "symmetric")
head(eigenvals(pca), 5)
#eigenvalues quantify the inertia(variance) explained by each axis
screeplot(pca, bstick = TRUE, type = "l",
main = NULL)
#a screeplot of the eigenvalues, looking for a drastic change in slope, where this happens
#it shows you where to start(in this case stop after PC2)
#where your eigenvalues remain above the broken stick, this should be included
summary(eigenvals(pca))
spp <- allMyData[, 1:20] ## columns 1-20 contain the species data
env <- allMyData[, 21:26] ## columns 21-26 contain the environmental data
#Basic Ordination Plots
plot(ca1, choices = c(1,3),
scaling = "symmetric")
pco1 <- wcmdscale(vegdist(varespec), eig = TRUE)
round(eigenvals(pco1), 3)
pco2 <- wcmdscale(vegdist(varespec), eig = TRUE, add = "lingoes")
round(eigenvals(pco2), 3)
pco <- wcmdscale(vegdist(varespec), eig = TRUE)
plot(pco)
scrs <- scores(pco, choices = 1:2)
spp_scrs <- wascores(scrs, varespec,
expand = FALSE)
points(spp_scrs, col = "red", pch = 19)
data(dune)
set.seed(10)
(sol <- metaMDS(dune, trace = FALSE))
layout(matrix(1:2, ncol = 2))
plot(sol, main = "Dune NMDS plot"); stressplot(sol, main = "Shepard plot")
layout(1)
set.seed(10)
ordipointlabel(pca,
display = "sites",
scaling = "symmetric")
plot(pca, display = "sites",
scaling = "symmetric", type = "n")
points(pca, display = "sites",
scaling = "symmetric", pch = 19,
col = "#025196")
set.seed(10)
ordipointlabel(pca,
display = "sites",
scaling = "symmetric",
add = TRUE)
disp <- "species"
scl <- "symmetric"
plot(pca, display = disp,
scaling = scl, type = "n")
points(pca, display = disp,
scaling = scl, pch = 19,
col = "#025196")
set.seed(10)
ordipointlabel(pca,
display = disp,
scaling = scl,
add = TRUE)
disp <- c("sites", "species")
scl <- "symmetric"
plot(pca, display = disp,
scaling = scl, type = "n")
points(pca, display = disp[1],
scaling = scl, pch = 19,
col = "#025196")
points(pca, display = disp[2],
scaling = scl, pch = 19,
col = "#fdb338")
set.seed(10)
ordipointlabel(pca,
display = disp,
scaling = scl,
add = TRUE,
col = c(1,1), cex = c(0.7, 0.7))
data(dune, dune.env)
col_vec <- c("red", "blue", "orange", "grey")
disp <- "sites"
scl <- "symmetric"
ord <- rda(decostand(dune, method="hellinger"))
plot(ord, type = "n", scaling = scl,
display = disp)
cols <- with(dune.env, col_vec[Management])
points(ord, display = disp, scaling = scl,
pch = 19, col = cols, cex = 2)
lvl <- with(dune.env, levels(Management))
legend("topright", legend = lvl,
bty = "n", col = col_vec, pch = 19)
disp <- "sites"
scl <- "symmetric"
plot(ord, type = "n", scaling = scl,
display = disp)
ordihull(ord, groups = dune.env$Management,
col = col_vec,
scaling = scl, lwd = 2)
ordispider(ord, groups = dune.env$Management,
col = col_vec,
scaling = scl, label = TRUE)
points(ord, display = disp, scaling = scl,
pch = 21, col = "red", bg = "yellow")
disp <- "sites"
scl <- "symmetric"
plot(ord, type = "n", scaling = scl,
display = disp)
## ellipsoid hull
ordiellipse(ord, groups = dune.env$Management,
kind = "ehull", col = col_vec,
scaling = scl, lwd = 2)
## standard error of centroid  ellipse
ordiellipse(ord, groups = dune.env$Management,
draw = "polygon", col = col_vec,
scaling = scl, lwd = 2)
ordispider(ord, groups = dune.env$Management,
col = col_vec,
scaling = scl, label = TRUE)
points(ord, display = disp, scaling = scl,
pch = 21, col = "red", bg = "yellow")
setwd("~/Masters/Maps and Data/urban_sprawl_stats")
data<-read.csv("shortlist_data_0715.csv")
View(data)
###################LST#######################
LST.model<-lm(data$LST_mean~data$X.canopy+data$Imp.+data$BD+data$Income+data$river.distance..meters.)
summary(LST.model)
plot(LST.model)
##############################NO2######################
NO2.model<-lm(data$NO2_mean~data$Road.+data$Income+data$petrochem_distance+data$BD)
summary(NO2.model)
plot(NO2.model)
##########################GS#######################
GS.model<-lm(data$nearest_M~data$BD+data$Income)
summary(GS.model)
plot(GS.model)
##############################NO2######################
NO2.model<-lm(log(data$NO2_mean)~data$Road.+data$Income+data$petrochem_distance+data$BD)
summary(NO2.model)
plot(NO2.model)
NO2.model<-lm(sqrt(data$NO2_mean)~data$Road.+data$Income+data$petrochem_distance+data$BD)
summary(NO2.model)
plot(NO2.model)
##############################NO2######################
NO2.model<-lm(log(data$NO2_mean)~log(data$Road.)+log(data$Income)+log(data$petrochem_distance)+log(data$BD))
##############################NO2######################
NO2.model<-lm(log(data$NO2_mean)~log(data$Road.)+log(data$Income)+log(data$petrochem_distance)+data$BD)
##############################NO2######################
NO2.model<-lm(log(data$NO2_mean)~log(data$Road.)+log(data$Income)+data$petrochem_distance+data$BD)
##############################NO2######################
NO2.model<-lm(log(data$NO2_mean)~log(data$Road.)+data$Income+data$petrochem_distance+data$BD)
##############################NO2######################
NO2.model<-lm(log(data$NO2_mean)~data$Road.+data$Income+data$petrochem_distance+data$BD)
summary(NO2.model)
##############################NO2######################
NO2.model<-lm(data$NO2_mean~log(data$Road.)+log(data$Income)+log(data$petrochem_distance)+log(data$BD))
##############################NO2######################
NO2.model<-lm(data$NO2_mean~data$Road.+log(data$Income)+log(data$petrochem_distance)+log(data$BD))
##############################NO2######################
NO2.model<-lm(data$NO2_mean~data$Road.+data$Income+data$petrochem_distance+data$BD)
##########################GS#######################
GS.model<-lm(log(data$nearest_M)~data$BD+data$Income)
summary(GS.model)
plot(GS.model)
##########################GS#######################
GS.model<-lm(sqrt(data$nearest_M)~data$BD+data$Income)
summary(GS.model)
plot(GS.model)
plot(LST.model)
plot(LST.model, which=3)
NO2.ranked<-rank(data$NO2_mean)
NO2.ranked
ranked.data<-data.frame(NO2_mean=data$NO2_mean, NO2_ranked=NO2.ranked, income=data$Income,
BD=data$BD, petrochem=data$petrochem_distance, road=data$Road.)
View(ranked.data)
lm.no2.ranked<-lm(NO2_ranked~BD+petrochem+road+income, data=ranked.data)
summary(lm.no2.ranked)
plot(lm.no2.ranked)
GS.ranked<-rank(data$nearest_M)
ranked.GS.data-data.frame(GS=data$nearest_M, GS_ranked=GS.ranked, income=data$Income,
BD=data$BD)
View(ranked.GS.data)
GS.ranked<-rank(data$nearest_M)
ranked.GS.data-data.frame(GS=data$nearest_M, GS_ranked=GS.ranked, income=data$Income,
BD=data$BD)
GS.ranked<-rank(data$nearest_M)
ranked.GS.data<-data.frame(GS=data$nearest_M, GS_ranked=GS.ranked, income=data$Income,
BD=data$BD)
View(ranked.GS.data)
lm.GS.ranked<-lm(GS_ranked~BD+income, data=ranked.GS.data)
summary(lm.GS.ranked)
plot(lm.GS.ranked)
mcycle <- MASS::mcycle
head(mcycle)
plot(mcycle)
lm_mod<-lm(times~accel, data=mcycle)
termplot(lm_mod, partial.resid = TRUE, se = TRUE)
install.packages("mgcv")
library(mgcv)
gam_mod <- gam(accel~ s(times), data = mcycle)
plot(gam_mod, residuals = TRUE, pch = 1)
coef(gam_mod)
# Fit a GAM with 3 basis functions
gam_mod_k3 <- gam(accel ~ s(times, k = 3), data = mcycle)
gam_mod_k20<-gam(accel~s(times, k=20), data=mcycle)
par(mfrow = c(1, 2))
plot(gam_mod_k3, residuals = TRUE, pch = 1)
plot(gam_mod_k20, residuals = TRUE, pch = 1)
gam_mod <- gam(accel ~ s(times), data = mcycle, method = "REML")
coef(gam_mod)
gam_mod$sp
gam_mod_s1 <- gam(accel ~ s(times), data = mcycle, sp = 0.1)
gam_mod_s2 <- gam(accel ~ s(times), data = mcycle, sp = 0.0001)
par(mfrow = c(2, 1))
plot(gam_mod_s1, residuals = TRUE, pch = 1)
plot(gam_mod_s2, residuals = TRUE, pch = 1)
plot(gam_mod_s1, residuals = TRUE, pch = 1)
par(mfrow = c(1, 1))
plot(gam_mod_s1, residuals = TRUE, pch = 1)
plot(gam_mod_s2, residuals = TRUE, pch = 1)
gam_mod_sk<-gam(accel~s(times), data=mcycle, k=50, sp=0.0001)
gam_mod_sk<-gam(accel~s(times, k=50), data=mcycle, sp=0.0001)
plot(gam_mod_sk, residuals=TRUE, pch=1)
library(gamair)
data("mpg", package="gamair")
library(mgcv)
install.packages("gamair")
library(gamair)
data("mpg", package="gamair")
head(mpg)
mod_city<-gam(city.mpg~weight+length+price, data=mpg, method="REML")
plot(mod_city, pages = 1)
mod_city<-gam(city.mpg~s(weight)+s(length)+s(price), data=mpg, method="REML")
plot(mod_city, pages = 1)
mod_city<-gam(city.mpg~s(weight)+s(length)+s(price), data=mpg, method="REML")
plot(mod_city, pages = 1)
mod_city<-gam(city.mpg~s(weight)+s(length)+s(price), data=mpg, method="REML")
plot(mod_city, pages = 1)
